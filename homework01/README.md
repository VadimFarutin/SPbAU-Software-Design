# Выбор библиотеки
Рассмотрел `JCommander`, `Apache Commonc CLI` и `Argparse4j`.
`JCommander` использует аннотации для полей, я не хотел создавать лишние поля, исользовав только локальные переменные. В `Argparse4j` работа со значениями аргументов по умолчанию мне показалась более удобной и гибкой (можно выставить значение для отсутствующего флага сразу при конфигурировании парсера, не нужно потом проверять значение на `null`), чем в `Apache Commonc CLI`, поэтому в конечном итоге выбрал `Argparse4j`.

# Build
`./gradlew build`

# Архитектура 
<img src="https://github.com/VadimFarutin/SPbAU-Software-Design/blob/homework01/homework01/CLI_arch.png" width="1106" height="780">

CLI передает парсеру строку и получает от него команду. Запускает команду и получает от нее результат. 
Если в результате есть строка, печатает ее. Если в результате SessionState.EXIT, выходит из цикла.

Парсер делает подстановку переменных, обращаясь к Environment. Затем считывает из строки название команды и ее аргументы до символа пайпа.
Передает полученные значения фабрике команд и получает от нее команду. 
Так же передает фабрике предыдущую команду, при наличии этой команды она будет передана новой в качестве аргумента.

При запуске команд из CLI каждая команда обращается к своим аргументам, чтобы получить их значения
(аргументы-команды для этого запускают свое вычисление и т.д.). Команда может бросить исключение, оно будет обработано в CLI.
